#!/usr/bin/env python
import os
import sys
import subprocess
import re
import json
import time
import argparse
import jinja2

parser = argparse.ArgumentParser(description='''Scans a folder for mp4 files recorded with SJCam.

The scripts expects the filenames follow the naming scheme SJCam does:
YYYY_MMDD_HHMMSS_NNN.MP4
It goes through this list alphabetically.
Assumes every segment start with a max length file. By default, the
assumption is the loop is set. Eg. If loop setting is 10 minutes, than
it will result that every file will be 601 seconds long, so that 1
second will overlap.
SJcam (at least, my SJCam 6 Legend) records the timestamp of the end of
the file. On the other hand, gpx2video expects the starting time to be
recorded as creation_time metadata. File's duration + creation_time helps
identify overlapping parts and generate the resulting avidemux scripts.

The tool will generate .py files, what you can import into avidemux, so you
can do further editing on them.
If a file is not overlapping with the next one, that means, the recording
ended there, and a new session needs to be started with the next file if
there's any.
''')

parser.add_argument('-d', '--destdir', default='.', help='Destionation dir, where to save the resulted .py files')
parser.add_argument('-s', '--startno', default=0, type=int, help='Start number for sessions. Default=0')
parser.add_argument('-n', '--numdigits', default=1, type=int, help='Number of digits in session numbers. Default=1')
parser.add_argument('-u', '--suffix', default='u', help='Suffix for the output file, between the autogenerated prefix and the .py extension. Default=u')
parser.add_argument('-f', '--force', default=False, action='store_true', help='Overwrite files without confirmation')
parser.add_argument('-D', '--gpxdiff', default=30, type=int, help='Diff in seconds before and after in the resulted GPX session files. Default=30')
parser.add_argument('-j', '--gpxjoin', default='', help='Join sessions gpx data. Comma separated list of pairs separated with minus. Eg. 1-2,4-5 Indexing always start from 0 in this case, no matter what is defined in the --startno parameter')
parser.add_argument('dir', help='Directory name to scan')

args = parser.parse_args()

last_session = -1
def get_video_info(filename):
    subproc = subprocess.run(['ffprobe', '-of', 'json', '-show_entries', 'format', filename], capture_output=True)
    video_data = json.loads(subproc.stdout)
    return {
            'len': float(video_data['format']['duration']),
            'ctime': time.strptime(video_data['format']['tags']['creation_time'], '%Y-%m-%dT%H:%M:%S.%fZ')
            }

class RecSession:
    '''
    Class to track recording session data
    '''
    def __init__(self, numdigits = 1, start_session_no = 0, dirname=None, force=False, suffix='u', destdir='.', gpxdiff=30, gpxjoins=[]):
        self.__session_no = start_session_no-1
        self.__numdigits = numdigits
        self.__reset()
        self.__destdir = destdir
        self.__suffix = suffix
        self.__force = force
        self.__gpxjoins = gpxjoins
        self.__gpxdiff = gpxdiff
        self.__sessions = []
        self.__dirname = dirname
        jenv = jinja2.Environment()
        jenv.filters['lnorm'] = lambda x: str(round(x*1000)*1000)
        self.__template = jenv.from_string('''#PY  <- Needed to identify #
#--automatically built--

adm = Avidemux()
{%- for i in range(files|length) %}
if not adm.{{ 'loadVideo' if i == 0 else 'appendVideo' }}("{{ files[i].file }}"):
    raise("Cannot {{ 'load' if i == 0 else 'append' }} {{ files[i].file }}")
{%- endfor %}
adm.clearSegments()
{%- for i in range(files|length) %}
adm.addSegment({{ i }}, 0, {{ files[i]['len'] | lnorm }})
{%- endfor %}
adm.markerA = 0
adm.markerB = {{ full_length | lnorm }}
adm.setPostProc(3, 3, 0)
adm.videoCodec("Copy")
adm.audioClearTracks()
adm.setSourceTrackLanguage(0,"und")
if adm.audioTotalTracksCount() <= 0:
    raise("Cannot add audio track 0, total tracks: " + str(adm.audioTotalTracksCount()))
adm.audioAddTrack(0)
adm.audioCodec(0, "copy")
adm.audioSetDrc(0, 0)
adm.audioSetShift(0, 0, 0)
adm.setContainer("MKV", "forceAspectRatio=False", "displayWidth=1280", "displayAspectRatio=2", "addColourInfo=False", "colMatrixCoeff=2", "colRange=0", "colTransfer=2", "colPrimaries=2")

''')

    def __reset(self):
        self.__prefix = None
        self.__length = 0
        self.__files = []
        self.__session_no += 1

    def __render(self):
        self.__sessions.append({
            'start_time': (time.mktime(self.__files[0]['ctime'])-self.__files[0]['len']),
            'stop_time': time.mktime(self.__files[-1]['ctime']),
            'prefix': self.__prefix + 'S'+ (f'%0{self.__numdigits}d' % self.__session_no)
            })
        outfilename = os.path.join(self.__destdir, self.__prefix + 'S' + ( f'%0{self.__numdigits}d' % self.__session_no ) + f'{self.__suffix}.py')
        # Update each file's length to not overlap with the next one
        for i in range(len(self.__files)-1):
            # Because of the shenanigans described below, I will just assume, the overlapping period is one second.
            self.__files[i]['len'] -= 1
            # Theory would dictate, this fix below is the right way to fix the lengths.
            #self.__files[i].update({
            #    # Current file's lenght should be next file's start time - this file's start time
            #    # For SJCam recordings a file's start time = file's ctime - file's len
            #    'len': (time.mktime(self.__files[i+1]['ctime']) - round(self.__files[i+1]['len'])) -
            #            (time.mktime(self.__files[i]['ctime']) - round(self.__files[i]['len']))
            #            })
            # But this whole thing is not working in certain cases.
            # I have an SJCam recording with the following filename: 2023_0527_203424_501.MP4
            # So, the actual start time is 2023-05-27T20:34:24
            #  $ ffprobe -of json -show_entries format 2023_0527_203424_501.MP4 2>/dev/null | jq .format.duration,.format.tags.creation_time
            #  "489.600000"
            #  "2023-05-27T20:42:32.000000Z"
            #  $ python -c "import time ; print(time.gmtime(time.mktime(time.strptime('2023-05-27T20:34:24.000000Z', '%Y-%m-%dT%H:%M:%S.%fZ'))+489))"
            #  time.struct_time(tm_year=2023, tm_mon=5, tm_mday=27, tm_hour=20, tm_min=42, tm_sec=33, tm_wday=5, tm_yday=147, tm_isdst=0)
            # Which means, that the ctime should be, at least 2023-05-27T20:42:33 or even above.
            # Because of this messup, I should probably fix the sjdemux script as well, to completely ignore the ctime, and
            # calculate the start-time based on the filename
        for fi in self.__files:
            self.__length += fi['len']
        if os.path.exists(outfilename) and not self.__force:
            answer = input(f'Can I overwrite {outfilename}? [y/N] ')
            if answer.lower() != 'y':
                print('Skipping this one as requested')
                return
        with open(outfilename, 'w') as outfile:
            outfile.write(self.__template.render(files=self.__files, full_length=self.__length))

    def flush(self):
        if len(self.__files) > 0:
            self.__render()
            self.__reset()

    def addfile(self, filename):
        full_filename = os.path.join(self.__dirname, filename)
        prefix = mre.match(filename).group('prefix')
        video_info = get_video_info(full_filename)
        video_info.update({'file': full_filename})
        # If start time doesn't overlap with last file in session we must flush the previous session
        if len(self.__files) > 0:
            if time.mktime(self.__files[-1]['ctime']) < (time.mktime(video_info['ctime']) - video_info['len']):
                self.flush()
        # If this is the first file in the session set the prefix
        if self.__prefix is None:
            self.__prefix = prefix
        self.__files.append(video_info)

    def gpxflush(self):
        gpxlogs = [ i for i in os.listdir(self.__dirname) if i.endswith('.gpx') ]
        gpxranges = []
        # Copy the sessions data into the local gpxranges var.
        for fi in self.__sessions:
            gpxranges.append(dict(fi))
        # Go through the ranges of sessions to join, and for every session in between
        for i in self.__gpxjoins:
            for j in range(i[0], i[1]+1):
                gpxranges[j]['start_time']=gpxranges[i[0]]['start_time']
                gpxranges[j]['stop_time']=gpxranges[i[1]]['stop_time']
        tre = re.compile('.*<trkpt.*<time>(?P<time>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z)</time>.*')
        for i in gpxranges:
            gpxlog = [ j for j in gpxlogs if j.startswith(i['prefix'][0:4] + i['prefix'][5:9]) ]
            if len(gpxlog) < 1 :
                continue
            # The gpslog will always be in UTC timezone
            # But the camera clock is set to local time
            # To bridge the difference, we alter the camera clock so the start and stop times
            # of the session will be converted to gmt
            start_time = time.mktime(time.gmtime(i['start_time'])) - self.__gpxdiff
            stop_time  = time.mktime(time.gmtime(i['stop_time' ])) + self.__gpxdiff
            outfilename = os.path.join(self.__destdir, i['prefix'] + '.gpx')
            infilename = os.path.join(self.__dirname, gpxlog[0])
            if os.path.exists(outfilename) and not self.__force:
                answer = input(f'Can I overwrite {outfilename}? [y/N] ')
                if answer.lower() != 'y':
                    print('Skipping this one as requested')
                    continue
            with open(infilename, 'r') as infile:
                with open(outfilename, 'w') as outfile:
                    for line in infile.readlines():
                        m = tre.match(line)
                        if m: # If it's a gps track point, it must be checked if the point is between the given intervalls
                            ltime = time.mktime(time.strptime(m.group('time'), '%Y-%m-%dT%H:%M:%SZ'))
                            if ltime < stop_time and ltime > start_time:
                                outfile.write(line)
                        else: # Else, it's a different part of the file, can be passed through
                            outfile.write(line)


mre = re.compile('^(?P<prefix>\d{4}_\d{4}_)\d{6}_\d{3}.mp4', re.I)
list_of_files = sorted([i for i in os.listdir(args.dir) if mre.match(i) ])

sessions = RecSession(
        numdigits=args.numdigits,
        start_session_no=args.startno,
        dirname=args.dir,
        force=args.force,
        suffix=args.suffix,
        gpxdiff=args.gpxdiff,
        gpxjoins=[ [int(j) for j in i.split('-') ] for i in args.gpxjoin.split(',') if len(i.split('-')) > 1 ],
        destdir=args.destdir)

for fn in list_of_files:
    sessions.addfile(fn)
sessions.flush()
sessions.gpxflush()
