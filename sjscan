#!/usr/bin/env python
import os
import sys
import subprocess
import re
import json
import argparse
import jinja2

parser = argparse.ArgumentParser(description='''Scans a folder for mp4 files recorded with SJCam.

The scripts expects the filenames follow the naming scheme SJCam does:
YYYY_MMDD_HHMMSS_NNN.MP4
It goes through this list alphabetically.
Assumes every segment start with a max length file. By default, the
assumption is the loop is set to 10 minutes. So every file will be 601
seconds long, so that 1 second will overlap.
It will generate .py files, what you can import into avidemux, so you
can do editing on it.
If a file is not loop+1 second long, but shorter, that means, the
recording ended there, and a new session needs to be started with
the next file if there's any.
''')

parser.add_argument('-d', '--destdir', default='.', help='Destionation dir, where to save the resulted .py files')
parser.add_argument('-l', '--deflength', default=600, type=int, help='Default segment length/ loop time in seconds. (Without the overlapping second) Default=600')
parser.add_argument('-s', '--startno', default=0, type=int, help='Start number for sessions. Default=0')
parser.add_argument('-n', '--numdigits', default=1, type=int, help='Number of digits in session numbers')
parser.add_argument('-u', '--suffix', default='u', help='Suffix for the output file, between the autogenerated prefix and the .py extension. Default=u')
parser.add_argument('-f', '--force', default=False, action='store_true', help='Overwrite files without confirmation')
parser.add_argument('dir', help='Directory name to scan')

args = parser.parse_args()

last_session = -1
def get_segment_length(filename):
    subproc = subprocess.run(['ffprobe', '-of', 'json', '-show_entries', 'format', filename], capture_output=True)
    video_data = json.loads(subproc.stdout)
    return float(video_data['format']['duration'])

class RecSession:
    '''
    Class to track recording session data
    '''
    def __init__(self, deflen=0, numdigits = 1, start_session_no = 0, dirname=None, force=False, suffix='u', destdir='.'):
        self.__deflen = deflen
        self.__session_no = start_session_no-1
        self.__numdigits = numdigits
        self.__reset()
        self.__destdir = destdir
        self.__suffix = suffix
        self.__force = force
        self.__dirname = dirname
        jenv = jinja2.Environment()
        jenv.filters['lnorm'] = lambda x: str(round(x*1000)*1000)
        self.__template = jenv.from_string('''#PY  <- Needed to identify #
#--automatically built--

adm = Avidemux()
{%- for i in range(files|length) %}
if not adm.{{ 'loadVideo' if i == 0 else 'appendVideo' }}("{{ files[i].file }}"):
    raise("Cannot {{ 'load' if i == 0 else 'append' }} {{ files[i].file }}")
{%- endfor %}
adm.clearSegments()
{%- for i in range(files|length) %}
adm.addSegment({{ i }}, 0, {{ files[i]['len'] | lnorm }})
{%- endfor %}
adm.markerA = 0
adm.markerB = {{ full_length | lnorm }}
adm.setPostProc(3, 3, 0)
adm.videoCodec("Copy")
adm.audioClearTracks()
adm.setSourceTrackLanguage(0,"und")
if adm.audioTotalTracksCount() <= 0:
    raise("Cannot add audio track 0, total tracks: " + str(adm.audioTotalTracksCount()))
adm.audioAddTrack(0)
adm.audioCodec(0, "copy")
adm.audioSetDrc(0, 0)
adm.audioSetShift(0, 0, 0)
adm.setContainer("MKV", "forceAspectRatio=False", "displayWidth=1280", "displayAspectRatio=2", "addColourInfo=False", "colMatrixCoeff=2", "colRange=0", "colTransfer=2", "colPrimaries=2")

''')

    def __reset(self):
        self.__prefix = None
        self.__length = 0
        self.__files = []
        self.__session_no += 1

    def __render(self):
        outfilename = os.path.join(self.__destdir, self.__prefix + 'S' + ( f'%0{args.numdigits}d' % self.__session_no ) + f'{self.__suffix}.py')
        if os.path.exists(outfilename) and not self.__force:
            answer = input(f'Can I overwrite {outfilename}? [y/N] ')
            if answer.lower() != 'y':
                print('Skipping this one as requested')
                return
        with open(outfilename, 'w') as outfile:
            outfile.write(self.__template.render(files=self.__files, full_length=self.__length))

    def flush(self):
        if len(self.__files) > 0:
            self.__render()
            self.__reset()

    def addfile(self, filename):
        prefix = mre.match(filename).group('prefix')
        full_filename = os.path.join(self.__dirname, filename)
        seg_len = get_segment_length(full_filename)
        if self.__prefix is None:
            self.__prefix = prefix
        clen = min(self.__deflen, seg_len)
        self.__files.append({'file': full_filename, 'len': clen})
        self.__length += clen
        if clen < self.__deflen:
            self.flush()


mre = re.compile('^(?P<prefix>\d{4}_\d{4}_)\d{6}_\d{3}.mp4', re.I)
list_of_files = sorted([i for i in os.listdir(args.dir) if mre.match(i) ])

sessions = RecSession(
        deflen=args.deflength,
        numdigits=args.numdigits,
        start_session_no=args.startno,
        dirname=args.dir,
        force=args.force,
        suffix=args.suffix,
        destdir=args.destdir)

for fn in list_of_files:
    sessions.addfile(fn)
sessions.flush()
