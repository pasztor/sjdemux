#!/usr/bin/env python
import os
import sys
import subprocess
import re
import json
import time
import argparse
import jinja2

parser = argparse.ArgumentParser(description='''Scans a folder for mp4 files recorded with SJCam.

The scripts expects the filenames follow the naming scheme GoPro does:

GXNNMMMM.MP4

gpx2video expects the starting time to be recorded as creation_time in
the file metadata.
File's duration + creation_time helps identify overlapping parts and
generate the resulting avidemux scripts.

The tool will generate .py files, what you can import into avidemux, so you
can do further editing on them.

Sometimes I only have a quick stop to wipe off bugs, etc. But on the map
I want to have them considered the same session, even if I stop the camera
for that time. From editing point of view, I don't mind identifying them
as separate sessions. But on the resulting gpx file I want them to be
considered as the same track. For this, you can user the -j option.

ENVIRONMENT:

  * Setting of SJTZ environment variable will override TZ for this script.
''', formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('-d', '--destdir', default='.', help='Destionation dir, where to save the resulted .py files')
parser.add_argument('-s', '--startno', default=0, type=int, help='Start number for sessions. Default=0')
parser.add_argument('-n', '--numdigits', default=1, type=int, help='Number of digits in session numbers. Default=1')
parser.add_argument('-u', '--suffix', default='u', help='Suffix for the output file, between the autogenerated prefix and the .py extension. Default=u')
parser.add_argument('-f', '--force', default=False, action='store_true', help='Overwrite files without confirmation')
parser.add_argument('-t', '--trace', default=False, action='store_true', help='Print extensive amount of debug information')
parser.add_argument('-D', '--gpxdiff', default=30, type=int, help='Diff in seconds before and after in the resulted GPX session files. Default=30')
parser.add_argument('-j', '--gpxjoin', default='', help='Join sessions gpx data. Comma separated list of pairs separated with minus. Eg. 1-2,4-5 Indexing always start from 0 in this case, no matter what is defined in the --startno parameter')
parser.add_argument('dir', help='Directory name to scan')

args = parser.parse_args()

def get_video_info(filename):
    subproc = subprocess.run(['ffprobe', '-of', 'json', '-show_entries', 'format:streams', filename], capture_output=True)
    video_data = json.loads(subproc.stdout)
    return {
            'len': float(video_data['streams'][0]['duration']),
            'ctime': time.strptime(video_data['format']['tags']['creation_time'], '%Y-%m-%dT%H:%M:%S.%fZ')
            }

def check_lrv_file(filename):
    subproc = subprocess.run(['ffprobe', '-of', 'json', '-show_entries', 'format:streams', filename], capture_output=True)
    ovf = json.loads(subproc.stdout)
    nmatch = mre.match(os.path.basename(filename))
    newfile = os.path.join( os.path.dirname(filename), f'GL{nmatch.group("n")}{nmatch.group("m")}.LRV' )
    if os.path.isfile(newfile):
        subproc = subprocess.run(['ffprobe', '-of', 'json', '-show_entries', 'format:streams', newfile], capture_output=True)
        nvf = json.loads(subproc.stdout)
        try:
            assert ovf['format']['duration'] == nvf['format']['duration'], "GL and GX file's duration isn't matching"
            assert ovf['streams'][0]['duration'] == nvf['streams'][0]['duration'], "GL and GX file's stream0 duration isn't matching"
            assert ovf['streams'][1]['duration'] == nvf['streams'][1]['duration'], "GL and GX file's stream1 duration isn't matching"
        except AssertionError as e:
            print(f'{e}, GX: {filename}, GL: {newfile}', file=sys.stderr)
            return None
        return newfile
    return None

class RecSessions:
    '''
    Class to track recording session data
    '''
    def __init__(self, numdigits = 1, start_session_no = 0, dirname=None, force=False, suffix='u', destdir='.', gpxdiff=30, gpxjoins=[]):
        self.__numdigits = numdigits
        self.__prefix = None
        self.__session_no = 0
        self.__destdir = destdir
        self.__suffix = suffix
        self.__force = force
        self.__gpxjoins = gpxjoins
        self.__gpxdiff = gpxdiff
        self.__sessions = {}
        self.__dirname = dirname
        self.__flatsessions = []
        jenv = jinja2.Environment()
        jenv.filters['lnorm'] = lambda x: str(round(x*1000)*1000)
        self.__template = jenv.from_string('''#PY  <- Needed to identify #
#--automatically built--

adm = Avidemux()
{%- for i in range(files|length) %}
if not adm.{{ 'loadVideo' if i == 0 else 'appendVideo' }}("{{ files[i].file }}"):
    raise("Cannot {{ 'load' if i == 0 else 'append' }} {{ files[i].file }}")
{%- endfor %}
adm.clearSegments()
{%- for i in range(files|length) %}
adm.addSegment({{ i }}, 0, {{ files[i]['len'] | lnorm }})
{%- endfor %}
adm.markerA = 0
adm.markerB = {{ full_length | lnorm }}
adm.setPostProc(3, 3, 0)
adm.videoCodec("Copy")
adm.audioClearTracks()
adm.setSourceTrackLanguage(0,"und")
if adm.audioTotalTracksCount() <= 0:
    raise("Cannot add audio track 0, total tracks: " + str(adm.audioTotalTracksCount()))
adm.audioAddTrack(0)
adm.audioCodec(0, "copy")
adm.audioSetDrc(0, 0)
adm.audioSetShift(0, 0, 0)
adm.setContainer("MKV", "forceAspectRatio=False", "displayWidth=1280", "displayAspectRatio=2", "addColourInfo=False", "colMatrixCoeff=2", "colRange=0", "colTransfer=2", "colPrimaries=2")

''')

    def __render(self, sid):
        session = self.__sessions[sid]
        session['sno'] = self.__session_no
        self.__session_no += 1
        session['prefix'] = self.__prefix + '_S' + ( f'%0{self.__numdigits}d' % session['sno'] )
        outfilename = os.path.join(self.__destdir, session['prefix'] + f'{self.__suffix}.py')
        # Calculate session's length
        session['length'] = float(0)
        for fi in session['files']:
            session['length'] += fi['len']
        session['start_time'] = time.mktime(session['ctime'])
        session['stop_time'] = session['start_time'] + session['length']
        if os.path.exists(outfilename) and not self.__force:
            answer = input(f'Can I overwrite {outfilename}? [y/N] ')
            if answer.lower() != 'y':
                print('Skipping this one as requested')
                return
        lrvfiles = [ check_lrv_file(i['file']) for i in self.__sessions[sid]['files'] ]
        if all(lrvfiles):
            args.trace and print(f'lrvfiles: {lrvfiles}')
            for i in range(len(lrvfiles)):
                self.__sessions[sid]['files'][i]['file'] = lrvfiles[i]
        with open(outfilename, 'w') as outfile:
            outfile.write(self.__template.render(files=self.__sessions[sid]['files'], full_length=self.__sessions[sid]['length']))
        self.__flatsessions.append(session)

    def flush(self):
        args.trace and print('flush:\n' + json.dumps(self.__sessions, indent=2))
        if len(self.__sessions) > 0:
            for i in self.__sessions:
                self.__render(i)
        for i in range(len(self.__flatsessions)):
            assert self.__flatsessions[i]['sno'] == i, 'flat sessionss index are the same as the sno in the session data'

    def addfile(self, filename):
        full_filename = os.path.join(self.__dirname, filename)
        n = mre.match(filename).group('n')
        m = mre.match(filename).group('m')
        video_info = get_video_info(full_filename)
        video_info.update({'file': full_filename})
        t = video_info['ctime']
        # If this is the first file in the session set the prefix
        if self.__prefix is None:
            self.__prefix = f'{t.tm_year}_{t.tm_mon:02}{t.tm_mday:02}'
        self.__sessions.setdefault(m, {'ctime': t, 'files': [] })
        self.__sessions[m]['files'].append(video_info)
        try:
            assert self.__sessions[m]['ctime'] == t, 'ctime mismatch between the same gopro sessions, need to investigate'
        except AssertionError as e:
            print(f'{e}\nsession ctime: {self.__sessions[m]["ctime"]}\nt: {t}\nfilename: {filename}')

    def gpxflush(self):
        gpxlogs = [ i for i in os.listdir(self.__dirname) if i.endswith('.gpx') ]
        #gpxranges = []
        # Copy the sessions data into the local gpxranges var.
        #for fi in self.__sessions:
        #    gpxranges.append(dict(fi))
        gpxranges = self.__flatsessions
        # Go through the ranges of sessions to join, and for every session in between
        for i in self.__gpxjoins:
            for j in range(i[0], i[1]+1):
                print(f'Debug:\ni: {i}\nj: {j}\ngpxjoins: {self.__gpxjoins}\n')
                print(json.dumps(gpxranges, indent=2))
                gpxranges[j]['start_time']=gpxranges[i[0]]['start_time']
                gpxranges[j]['stop_time']=gpxranges[i[1]]['stop_time']
        tre = re.compile('.*<trkpt.*<time>(?P<time>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z)</time>.*')
        args.trace and print(f'gpxranges:\n' + json.dumps(gpxranges, indent=2))
        for i in gpxranges:
            # gpxlog uses the following file name pattern: "YYYYmmdd-HHMMss - TRACKNAME.gpx"
            # For me: One day, one gpx file, so it's enough to match only on the day.
            # Than let the sjscan do the splitting it into sessions, but join them where I
            # explicitly specify via the -j option.
            gpxlog = [ j for j in gpxlogs if j.startswith(i['prefix'][0:4] + i['prefix'][5:9]) ]
            if len(gpxlog) < 1 :
                continue
            # The gpslog will always be in UTC timezone
            # But the camera clock is set to local time
            # To bridge the difference, we alter the camera clock so the start and stop times
            # of the session will be converted to gmt
            start_time = time.mktime(time.gmtime(i['start_time'])) - self.__gpxdiff
            stop_time  = time.mktime(time.gmtime(i['stop_time' ])) + self.__gpxdiff
            outfilename = os.path.join(self.__destdir, i['prefix'] + '.gpx')
            infilename = os.path.join(self.__dirname, gpxlog[0])
            if os.path.exists(outfilename) and not self.__force:
                answer = input(f'Can I overwrite {outfilename}? [y/N] ')
                if answer.lower() != 'y':
                    print('Skipping this one as requested')
                    continue
            with open(infilename, 'r') as infile:
                with open(outfilename, 'w') as outfile:
                    for line in infile.readlines():
                        m = tre.match(line)
                        if m: # If it's a gps track point, it must be checked if the point is between the given intervalls
                            ltime = time.mktime(time.strptime(m.group('time'), '%Y-%m-%dT%H:%M:%SZ'))
                            if ltime < stop_time and ltime > start_time:
                                outfile.write(line)
                        else: # Else, it's a different part of the file, can be passed through
                            outfile.write(line)


if 'SJTZ' in os.environ:
    os.environ['TZ'] = os.environ['SJTZ']
    time.tzset()

if not os.path.exists(args.destdir):
    print(f'Destination directory {args.destdir} does not exist, creating it now', file=sys.stderr)
    os.makedirs(args.destdir)

mre = re.compile('^GX(?P<n>\d{2})(?P<m>\d{4}).MP4', re.I)
list_of_files = sorted([i for i in os.listdir(args.dir) if mre.match(i) ])

sessions = RecSessions(
        numdigits=args.numdigits,
        start_session_no=args.startno,
        dirname=args.dir,
        force=args.force,
        suffix=args.suffix,
        gpxdiff=args.gpxdiff,
        gpxjoins=[ [int(j) for j in i.split('-') ] for i in args.gpxjoin.split(',') if len(i.split('-')) > 1 ],
        destdir=args.destdir)

for fn in list_of_files:
    sessions.addfile(fn)
sessions.flush()
sessions.gpxflush()
